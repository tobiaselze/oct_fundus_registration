
#' @import randomForest
#' @import RNiftyReg
#' @importFrom infotheo mutinformation discretize entropy
#' @importFrom tiff readTIFF writeTIFF
#' @importFrom utils read.csv download.file
#' @importFrom stats cor
NULL



#' Random forest model for failureAlert fitted on Spectralis HD-OCT 768x768 pixel SLO fundus images
#'
#' This model is used to calculate failureAlert from the registration 
#' parameters determined by \code{register.mac.onh.affine}
#'
#' @docType data
"failure.alert.spectralis.768.model"


#' Normalized mutual information
#'
#' Calculate normalized mutual information defined by
#' mutinformation(x, y) / sqrt(entropy(x) * entropy(y))
#' using the mutinformation function from library infotheo
#' 
#' @param x vector containing data
#' @param y another vector containing data
#' @return normalized mutual information.
#' @export
nmi <- function(x, y)
#### in theory not needed, see RNiftyReg::similarity,
#### but the latter returns strange results
{
	x1 = discretize(x)
	y1 = discretize(y)
	mutinformation(x1, y1) / sqrt(entropy(x1) * entropy(y1))
}


failure.prob <- function(v, m=failure.alert.spectralis.768.model)
# probability of registration failure as estimated by model m
{
	predict(m, newdata=as.list(v), type="prob")[1]
}


#' Register a macular centered and an ONH centered OCT fundus image
#'
#' Registers a pair of grayscale macular centered and optic nerve head (ONH)
#' centered fundus images, as typically generated by optical coherence 
#' tomography machines (often by SLO technology). Both images must be stored
#' as TIFF files in the same directory. The ONH centered image file name must
#' end on _onh.tif, the corresponding macular image file must be identical to
#' the ONH file name except for ending on _mac.tif.
#' This is essentially a wrapper around niftyreg() from library RNiftyReg.
#' 
#' @param onhfilename file name of the ONH centered tif file
#' @param default.x.shift.percent starting value of the horizontal shift of the ONH image relative to the macular centered image in percent
#' @param failureAlertModel model to calculate failureAlert (see Value); defaults to failure.alert.spectralis.768.model, a random forest model trained on 768x768 pixel Spectralis HD-OCT SLO images
#' @return A list of two elements: transVector and mosaic, where mosaic is the combined image after registration (as a real matrix), with the non-overlapping parts appearing in 50 percent darker gray levels and transVector a named vector with the following fields describing the affine transform and its reliability:
#' \describe{
#' 	\item{transx:}{horizontal translation}
#' 	\item{transy:}{vertical translation}
#' 	\item{rotation:}{rotation (in degree)}
#' 	\item{scalex:}{horizontal scaling factor}
#' 	\item{scaley:}{vertical scaling factor}
#' 	\item{skew:}{skew}
#' 	\item{percentOverlap:}{overlap of the two images after registration, in percent}
#' 	\item{pearsonCor:}{Pearson's correlation coefficient of the overlapping pixels}
#' 	\item{nmi:}{normalized mutual information of the overlapping pixels (see \code{\link{nmi}})}
#' 	\item{niftiregSimilarity:}{similarity parameter returned by the niftyreg() function}
#' 	\item{failureAlert:}{reliability prediction of the registration; the higher this value, the higher the probability of a registration failure; bounded between 0 (lowest error probability) and 1}
#' }
#'
#' @seealso [affine.register.directory()]
#' @examples
#' \dontrun{
#' # download an example ONH <-> macular fundus image pair:
#' url.dir = "https://github.com/tobiaselze/oct_fundus_registration/raw/main/image_examples/"
#' download.file(paste0(url.dir, "example1_onh.tif"), "example1_onh.tif")
#' download.file(paste0(url.dir, "example1_mac.tif"), "example1_mac.tif")
#' 
#' # register the image pair example1_onh.tif and example1_mac.tif:
#' r <- register.mac.onh.affine("example1_onh.tif")
#' # write the combined (mocaiced) image to a file:
#' writeTIFF(r$mosaic, "example1_mosaic.tif")
#' }
#' @export
register.mac.onh.affine <- function(
	onhfilename,
	default.x.shift.percent = 40,
	failureAlertModel = failure.alert.spectralis.768.model)
{
	macfilename = gsub("_onh.tif$", "_mac.tif", onhfilename)
	if(file.exists(macfilename) && file.exists(onhfilename) && macfilename != onhfilename)
	{
		cat(basename(macfilename), "<->", basename(onhfilename), "\n")
		macorig = readTIFF(macfilename)
		onhorig = readTIFF(onhfilename)
		xshift = round((default.x.shift.percent/100)*ncol(macorig))
		
		# fill images with NA to shift the onh image by default.x.shift.percent:
		fill = matrix(rep(NA, xshift*nrow(macorig)), ncol=xshift)
		mac = cbind(macorig, fill)
		onh = cbind(fill, onhorig)
		# masks for image registration:
		maskmac = ifelse(is.na(mac), 0, 1)
		maskonh = ifelse(is.na(onh), 0, 1)
				
		default.trans.vec <- c(rep(NA, 10), failureAlert=1.1)
		
		try.registration <- function(nLevels=3L, maxIterations=5L, tv=default.trans.vec, rtmp=NULL)
		{
			if(nLevels < 3L)
				list(r=rtmp, transVector=tv)
			else {
				cat("nLevels:", nLevels, "-- maxIterations:", maxIterations, "\n")
				r <- NULL
				try(
					r <- niftyreg(
						onh, mac, 
						sourceMask=maskmac, targetMask=maskonh, 
						nLevels=nLevels, 
						maxIterations=maxIterations),
					silent=TRUE)
				if(is.null(r))
				{
					try.registration(nLevels - 1L, maxIterations - 1L, tv, rtmp)
				} else {
					d = decomposeAffine(forward(r))
							
					is.overlapping = !is.na(r$image) & !is.na(mac)
					n <- as.numeric
					
					# if outcome looks suspicious, give it a 2nd try with more iterations:
					mutinf = nmi(mac[is.overlapping], r$image[is.overlapping])
					skew = n(d$skews[1])
					
					# note: x and y are flipped by niftyreg; here, we represent them correctly:
					transVector = c(
						transx = n(d$translation[2]) + xshift,	# add default shift
						transy = n(d$translation[1]),
						rotation = n(d$angles[3])*180/pi,
						scalex = n(d$scales[2]),
						scaley = n(d$scales[1]),
						skew = skew,
						percentOverlap = 100*(sum(is.overlapping)/length(macorig)),
						pearsonCor = cor(mac[is.overlapping], r$image[is.overlapping]),
						nmi = mutinf,
						niftiregSimilarity = similarity(r$image, mac)
					)
					transVector["failureAlert"] <- failure.prob(transVector, failureAlertModel)
					if(transVector["failureAlert"] < tv["failureAlert"])
						try.registration(nLevels - 1L, maxIterations - 1L, transVector, r)
					else
						try.registration(nLevels - 1L, maxIterations - 1L, tv, rtmp)
				}
			}
		}
		
		rs <- try.registration()
		# failure probability >50%: try it with more iterations:
		if(rs$transVector["failureAlert"] > 0.5)
		{
			rs1 <- try.registration(nLevels=8L, maxIterations=10L)
			# choose the new estimate if the failure prob decreases:
			if(rs$transVector["failureAlert"] > rs1$transVector["failureAlert"])
				rs <- rs1
		}
		
		transVector <- rs$transVector
		r <- rs$r
		
		# generate mosaic:
		na2blk <- function(m) ifelse(is.na(m), 0, m)
		mosaic = (na2blk(mac) + na2blk(r$image))/2
		
		list(transVector = transVector, mosaic=mosaic)
		
	} else {
		stop("register.mac.onh.affine: File name pair ", macfilename, ",", onhfilename, " does not exist or is duplicated.")
	}
}


#' Generate affine transform from vector
#'
#' Convenience function to convert affine transform in vector representation
#' as returned by \code{register.mac.onh.affine} to the 
#' matrix representation needed by niftyreg
#' 
#' @param v vector containing affine transform as returned by \code{register.mac.onh.affine} 
#' @param sourceImage source image for the transformation (required)
#' @param xshift  default shift in horizontal direction in pixels
#' @export
affineVector2affineMatrix <- function(v, sourceImage, xshift=0)
{
	buildAffine(
		translation=c(v["transy"], v["transx"] - xshift, 0),
		angles=v["rotation"]*pi/180,
		scales=c(v["scaley"], v["scalex"], 1),
		skews=c(v["skew"], 0, 0),
		source=sourceImage)
}

#' Register all macular <-> ONH image pairs in directory
#'
#' Call \code{register.mac.onh.affine} on all *_onh.tif files
#' found in directory \code{dirname} and write registration
#' output to csv file
#'
#' @param dirname directory containing the source image pairs of the ONH and macula centered fundus images (*_onh.tif and corresponding *_mac.tif files)
#' @param outpath path for the output (csv and mosaics)
#' @param csvfile file that contains the transformation results; if the file exists, it will get appended
#' @param overwrite.existing if true, overwrite existing images/transformation results, otherwise skip them
#' @param write.mosaic if TRUE, mosaic is saved as a tiff file into outpath with same file name as onh file, but _onh replaced by _mosaic
#' @param ... arguments passed to \code{register.mac.onh.affine}
#'
#' @seealso [register.mac.onh.affine()]
#' @examples
#' \dontrun{
#' # generate a new directory and download six example ONH <-> macular fundus image pairs:
#' unregistered.image.dir = "unregistered_images/"
#' dir.create(unregistered.image.dir)
#' url.dir = "https://github.com/tobiaselze/oct_fundus_registration/raw/main/image_examples/"
#' 
#' for(i in 1:6)
#' {
#'   onhfile = paste0("example", i, "_onh.tif")
#'   macfile = paste0("example", i, "_mac.tif")
#'   download.file(paste0(url.dir, onhfile), paste0(unregistered.image.dir, onhfile))
#'   download.file(paste0(url.dir, macfile), paste0(unregistered.image.dir, macfile))
#' }
#' 
#' # register the images and write results and mosaic (combined) images
#' # to directory registration_results (generated in the current working dir):
#' affine.register.directory(unregistered.image.dir, "registration_results", write.mosaic=TRUE)
#' }
#' @export
affine.register.directory <- function(
	dirname, 
	outpath, 
	csvfile=paste0(outpath, "/registration_affine.csv"), 
	overwrite.existing = FALSE,
	write.mosaic = FALSE,
	...)
{
	onhfiles = dir(dirname, pattern="_onh.tif$", full.names=TRUE)
	ct <- function(...)
		cat(..., file=csvfile, append=TRUE)
	
	ids.to.skip = new.env()
	if(!overwrite.existing && file.exists(csvfile))
	{
		existing = read.csv(csvfile, colClasses="character")
		for(x in existing$measid)
			ids.to.skip[[x]] <- TRUE
	}
	
	reg <- function(onhfile)
	{
		measid = gsub("_onh.tif$", "", basename(onhfile))
		if(exists(measid, ids.to.skip))
			cat("Pair", measid, "already completed. Skipping...\n")
		else {
			trns = register.mac.onh.affine(onhfile, ...)
			r = trns$transVector
			if(!file.exists(csvfile))
			{
				if(!dir.exists(outpath))
					dir.create(outpath)
				cat("measid", names(r), sep=",", file=csvfile)
				ct("\n")
			}
			ct(paste0(measid, ","))
			ct(r, sep=",")
			ct("\n")
			
			if(write.mosaic)
			{
				mosaicfile = paste0(outpath, "/", gsub("_onh.tif$", "_mosaic.tif", basename(onhfile)))
				writeTIFF(trns$mosaic, mosaicfile)
			}
		}
	}
	invisible(lapply(onhfiles, reg))
}








